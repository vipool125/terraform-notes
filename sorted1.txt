Terraform vs ARM vs Bicep â€” Which do I prefer and why?
Feature	Terraform	Bicep	ARM Templates
Cloud Support	â­ Multi-cloud (AWS/Azure/GCP/K8s/VMware etc.)	âŒ Azure Only	âŒ Azure Only
Syntax	Friendly HCL, modular	Friendly DSL, ARM-native	JSON â€” verbose + error-prone
State Management	Yes (remote/local)	Yes (via Azure Resource Manager)	Yes (auto in ARM)
Ecosystem	Huge modules registry	Growing	Limited
Drift Detection	Full plan/apply	Good (Azure native)	Good
Maturity	Very mature	Actively improving	Legacy / hard to maintain
Preferred:
ðŸ‘‰ Terraform â€” because itâ€™s multi-cloud, has a huge ecosystem, and is better for enterprise scale modularization.
Bicep is great if:
	â€¢ Azure-only
	â€¢ Want first-party support + no external state backend
ARM is mostly legacy now (Bicep replaces it).

ðŸ§  How does Terraform maintain state?
Terraform keeps a record of the real-world infrastructure in a state file.
ðŸ“Œ State maps configuration â†’ actual resources
	â€¢ Tracks resource IDs, metadata, dependency graph
	â€¢ Detects drift + plans changes safely
ðŸ“Œ Storage options:
	â€¢ Local: terraform.tfstate
	â€¢ Remote: S3 + DynamoDB lock, Azure Blob + leases, GCS + locking, Terraform Cloud
ðŸ“Œ State locking prevents:
	â€¢ two people from doing apply simultaneously â†’ prevents race conditions
Example (Azure remote state):

terraform {
  backend "azurerm" {
    resource_group_name  = "rg-tfstate"
    storage_account_name = "tfstateprod"
    container_name       = "state"
    key                  = "prod.tfstate"
  }
}

ðŸ’¥ What happens if the Terraform state file gets corrupted?
Terraform wonâ€™t know the current resource state â†’ plan/apply may destroy/recreate incorrectly.
Recovery strategy:
	1. Backups â€” Terraform automatically stores previous state (*.backup)
	2. Versioned backend â€” S3 versioning, Azure Blob soft-delete â†’ restore correct version
	3. terraform refresh â†’ re-query cloud provider to rebuild missing state
	4. Manual fix â€” terraform state commands (advanced)
Worst case:
	â€¢ Import critical infrastructure back into state:

terraform import azurerm_storage_account.example /subscriptions/.../storageAccounts/xyz

âš™ï¸ Lifecycle Rules (Terraform Resource Lifecycle)
Used for safe deployments + drift tolerance.
create_before_destroy
Avoid downtime when replacing resources (e.g. ASG, ALB):

lifecycle {
  create_before_destroy = true
}
ignore_changes
When some fields are managed outside Terraform (autoscaling, Kubernetes):

lifecycle {
  ignore_changes = [
    tags,
    capacity,
  ]
}
Other useful ones:
	â€¢ prevent_destroy = true â€” protect critical resources (DBs)
	â€¢ replace_triggered_by â€” force recreate on external dependency change

ðŸ§© Terraform Modules â€” Why & How?
Modules = reusable infrastructure blocks.
Why:
	â€¢ Standardization + reusability
	â€¢ Reduce copy/paste
	â€¢ Enforce security + naming conventions
	â€¢ Cleaner code + easier onboarding
Structure:

root/
 â”œâ”€ main.tf
 â”œâ”€ variables.tf
 â”œâ”€ outputs.tf
 â””â”€ modules/
     â””â”€ vpc/
         â”œâ”€ main.tf
         â”œâ”€ variables.tf
         â””â”€ outputs.tf
Usage example:

module "vpc" {
  source = "./modules/vpc"
  cidr_block = "10.0.0.0/16"
}
You can also pull from Terraform Registry:

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 20.0"
}

ðŸ“Œ Summary for Interview Answers
Topic	One-liner
TF vs Bicep vs ARM	Terraform = multi-cloud, Bicep = Azure-native, ARM = legacy
State management	Maps config â†’ cloud resources; enables plan/drift detection + locking
State corruption	Restore backup/version â†’ refresh/import to rebuild mapping
Lifecycle rules	Control how Terraform creates/destroys and handles drift
Modules	DRY, reusable, scalable IaC with consistent standards
